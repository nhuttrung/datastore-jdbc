package vn.khtt.datastore.jdbc;

import com.google.appengine.api.datastore.DatastoreService;
import com.google.appengine.api.datastore.DatastoreServiceFactory;
import com.google.appengine.api.datastore.Entity;
import com.google.appengine.api.datastore.PreparedQuery;
import com.google.appengine.api.datastore.Query;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import net.sf.jsqlparser.JSQLParserException;
import net.sf.jsqlparser.expression.Expression;
import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
import net.sf.jsqlparser.parser.CCJSqlParserUtil;
import net.sf.jsqlparser.schema.Column;
import net.sf.jsqlparser.schema.Table;
import net.sf.jsqlparser.statement.alter.Alter;
import net.sf.jsqlparser.statement.create.table.ColumnDefinition;
import net.sf.jsqlparser.statement.create.table.CreateTable;
import net.sf.jsqlparser.statement.delete.Delete;
import net.sf.jsqlparser.statement.drop.Drop;
import net.sf.jsqlparser.statement.insert.Insert;
import net.sf.jsqlparser.statement.select.Select;
import net.sf.jsqlparser.statement.update.Update;

import vn.khtt.datastore.jdbc.calcite.DataTypeConverter;
import vn.khtt.datastore.jdbc.calcite.DatastoreField;
import vn.khtt.datastore.jdbc.calcite.DatastoreFieldType;
import vn.khtt.datastore.jdbc.calcite.DatastoreFilterableTable;
import vn.khtt.datastore.jdbc.calcite.DatastoreSchema;
import vn.khtt.datastore.jdbc.calcite.DatastoreTable;

public class DatastoreStatement implements Statement {
//    private static final DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    
    private DatastoreConnection conn;
    private Statement calciteStatement;
    
    private int maxRows;
    private int queryTimeout;
    
    public DatastoreStatement(DatastoreConnection conn, Statement calciteStatement) {
        this.conn = conn;
        this.calciteStatement = calciteStatement;
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        return executeQuery(sql, null);
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        net.sf.jsqlparser.statement.Statement stmt = parseSql(sql);
        
        if (stmt instanceof CreateTable){
            executeCreateTable((CreateTable)stmt);
            return 0;
        }

        if (stmt instanceof Insert){
            return executeInsert((Insert)stmt, null);
        }
        if (stmt instanceof Update){
            return executeUpdate((Update)stmt, null);
        }
        if (stmt instanceof Delete){
            return executeDelete((Delete)stmt, null);
        }
        
        notImplemented();
        return 0;
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        notImplemented();

        // TODO Implement this method
        return 0;
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        notImplemented();

        // TODO Implement this method
        return 0;
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        notImplemented();

        // TODO Implement this method
        return 0;
    }

    @Override
    public void close() throws SQLException {
//        notImplemented();

        // TODO Implement this method
    }

    @Override
    public int getMaxFieldSize() throws SQLException {
        notImplemented();

        // TODO Implement this method
        return 0;
    }

    @Override
    public void setMaxFieldSize(int max) throws SQLException {
        notImplemented();

        // TODO Implement this method
    }

    @Override
    public int getMaxRows() throws SQLException {
        return maxRows;
    }

    @Override
    public void setMaxRows(int max) throws SQLException {
        maxRows = max;
    }

    @Override
    public void setEscapeProcessing(boolean enable) throws SQLException {
        notImplemented();

        // TODO Implement this method
    }

    @Override
    public int getQueryTimeout() throws SQLException {
        return queryTimeout;
    }

    @Override
    public void setQueryTimeout(int seconds) throws SQLException {
        this.queryTimeout = seconds;
    }

    @Override
    public void cancel() throws SQLException {
        notImplemented();

        // TODO Implement this method
    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        return null;    // TODO
    }

    @Override
    public void clearWarnings() throws SQLException {
        // TODO
    }

    @Override
    public void setCursorName(String name) throws SQLException {
        notImplemented();

        // TODO Implement this method
    }

    @Override
    public boolean execute(String sql) throws SQLException {
        if (true){
//            return calciteStatement.execute(sql);
        }
        
        net.sf.jsqlparser.statement.Statement stmt = parseSql(sql);
        if (stmt instanceof Select){
            // TODO: #getResultSet and #getUpdateCount
            warnIfQueryInsideTransaction();
            return calciteStatement.execute(sql);
        }
        
        if (stmt instanceof CreateTable){
            executeCreateTable((CreateTable)stmt);
            return false;
        }
        if (stmt instanceof Drop){
            Drop drop = (Drop)stmt;
            if ("table".equals(drop.getType())){
                Table table = drop.getName();
                executeDrop(table);
                return false;
            }
        }
        
        if (stmt instanceof Insert){
            executeInsert((Insert)stmt, null);
            return false;
        }
        if (stmt instanceof Update){
            executeUpdate((Update)stmt, null);
            return false;
        }

        if (stmt instanceof Alter){
            Alter alter = (Alter)stmt;
            System.err.println("TODO: Alter");
            // TODO
            return false;
        }
        
        throw new RuntimeException("Unsupport statement: " + sql);
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        notImplemented();

        // TODO Implement this method
        return false;
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        notImplemented();

        // TODO Implement this method
        return false;
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        notImplemented();

        // TODO Implement this method
        return false;
    }

    @Override
    public ResultSet getResultSet() throws SQLException {
        return this.calciteStatement.getResultSet();
    }

    @Override
    public int getUpdateCount() throws SQLException {
        notImplemented();

        // TODO Implement this method
        return 0;
    }

    @Override
    public boolean getMoreResults() throws SQLException {
        notImplemented();

        // TODO Implement this method
        return false;
    }

    @Override
    public boolean getMoreResults(int current) throws SQLException {
        notImplemented();

        // TODO Implement this method
        return false;
    }

    @Override
    public void setFetchDirection(int direction) throws SQLException {
        notImplemented();

        // TODO Implement this method
    }

    @Override
    public int getFetchDirection() throws SQLException {
        notImplemented();

        // TODO Implement this method
        return 0;
    }

    @Override
    public void setFetchSize(int rows) throws SQLException {
        notImplemented();

        // TODO Implement this method
    }

    @Override
    public int getFetchSize() throws SQLException {
        notImplemented();

        // TODO Implement this method
        return 0;
    }

    @Override
    public int getResultSetConcurrency() throws SQLException {
        notImplemented();

        // TODO Implement this method
        return 0;
    }

    @Override
    public int getResultSetType() throws SQLException {
        notImplemented();

        // TODO Implement this method
        return 0;
    }

    @Override
    public void addBatch(String sql) throws SQLException {
        notImplemented();

        // TODO Implement this method
    }

    @Override
    public void clearBatch() throws SQLException {
        notImplemented();

        // TODO Implement this method
    }

    @Override
    public int[] executeBatch() throws SQLException {
        notImplemented();

        // TODO Implement this method
        return new int[0];
    }

    @Override
    public Connection getConnection() throws SQLException {
        return conn;
    }

    @Override
    public ResultSet getGeneratedKeys() throws SQLException {
        notImplemented();

        // TODO Implement this method
        return null;
    }

    @Override
    public int getResultSetHoldability() throws SQLException {
        notImplemented();

        // TODO Implement this method
        return 0;
    }

    @Override
    public boolean isClosed() throws SQLException {
        notImplemented();

        // TODO Implement this method
        return false;
    }

    @Override
    public void setPoolable(boolean poolable) throws SQLException {
        notImplemented();

        // TODO Implement this method
    }

    @Override
    public boolean isPoolable() throws SQLException {
        notImplemented();

        // TODO Implement this method
        return false;
    }

    @Override
    public void closeOnCompletion() throws SQLException {
        notImplemented();

        // TODO Implement this method
    }

    @Override
    public boolean isCloseOnCompletion() throws SQLException {
        notImplemented();

        // TODO Implement this method
        return false;
    }

    @Override
    public <T> T unwrap(Class<T> iface) throws SQLException {
        try {
            if (isWrapperFor(iface)) {
                return (T) this;
            }
            throw new SQLException();
        } catch (Exception e) {
            throw new SQLException(e);
        }        
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        return iface != null && iface.isAssignableFrom(getClass());
    }

    protected net.sf.jsqlparser.statement.Statement parseSql(String sql) throws SQLException {
        sql = conn.caseTransformer.transformSql(sql);
        try {
            return CCJSqlParserUtil.parse(sql);
        } catch (JSQLParserException e) {
            e.printStackTrace();
            throw new SQLException(sql, e);
        }
    }
    
    protected void executeCreateTable(CreateTable createTable) throws SQLException {
        Table table = createTable.getTable();
//        notImplemented();
        
        DatastoreTable datastoreTable = new DatastoreFilterableTable(table.getName());
        for (ColumnDefinition columnDef : createTable.getColumnDefinitions()){
            String fieldName = columnDef.getColumnName();
            String dataType = columnDef.getColDataType().getDataType();
            DatastoreFieldType fieldType = DatastoreFieldType.of(dataType);
            if (fieldType == null){
                throw new UnsupportedOperationException("SQL Data Type: " + dataType);
            }
            DatastoreField field = new DatastoreField(fieldName, fieldType);
            datastoreTable.addField(field);
        }
        DatastoreSchema.DEFAULT.addTable(datastoreTable);
    }
    
    private void executeDrop(Table table) throws SQLException {
        // TODO: Delete all Entities for this table
    }
    
    protected ResultSet executeQuery(String sql, Map<Integer, Object> params) throws SQLException {
        net.sf.jsqlparser.statement.Statement stmt = parseSql(sql);
        if (!(stmt instanceof Select)){
            throw new SQLException("SQL is not a SELECT statement: " + sql);
        }
        
        warnIfQueryInsideTransaction();
        return calciteStatement.executeQuery(sql);
    }
    
    protected int executeInsert(Insert insert, Map<Integer, Object> params) throws SQLException {
        if (params == null){
            params = new HashMap<Integer, Object>();
        }
        
        Table table = insert.getTable();
        String tableName = table.getName();

        // Determine columns to be inserted
        DatastoreTable datastoreTable = DatastoreSchema.DEFAULT.getDatastoreTable(tableName);
        List<Column> columns = insert.getColumns();
        if (columns == null){
            columns = new ArrayList<Column>();
            for (DatastoreField field : datastoreTable.getFields()){
                columns.add(new Column(table, field.getFieldName()));
            }
        }
        
        // create new Entity
        Entity entity = new Entity(tableName);
        int columnIndex = 0;
        for (Expression exp : ((ExpressionList)insert.getItemsList()).getExpressions()){
            Column column = columns.get(columnIndex++);
            String columnName = column.getColumnName();
            Object value = ExpressionUtils.convertExpression(exp, params);
            // TODO value = Utils.convertToColumnType(tableInfo, columnName, value);
            value = DataTypeConverter.convertToDatastore(value, datastoreTable, columnName);
            entity.setProperty(columnName, value);
        }
        if (conn.transaction != null){
            conn.datastore.put(conn.transaction, entity);
        } else {
            conn.datastore.put(entity);
        }

        return 1;
    }
    
    protected int executeUpdate(Update update, Map<Integer, Object> params) throws SQLException {
        if (update.getTables().size() != 1){
            notImplemented();
        }
        if (params == null){
            params = new HashMap<Integer, Object>();
        }
        
        Table table = update.getTables().get(0);
        String tableName = table.getName();

        // Determine table to be updated
        DatastoreTable datastoreTable = DatastoreSchema.DEFAULT.getDatastoreTable(tableName);

        Query q = new Query(tableName);
        Query.Filter filter = ExpressionUtils.buildFilterFromWhereClause(update.getWhere(), params);
        if (filter != null){
            q.setFilter(filter);
        }
        PreparedQuery pq = conn.datastore.prepare(q);
        
        List<Entity> entities = new ArrayList<Entity>();
        for (Entity entity : pq.asIterable()){
            entities.add(entity);
            List<Column> columns = update.getColumns();
            if (columns != null){
                List<Expression> expressions = update.getExpressions();
                int columnIndex = 0;
                for (Column column : columns){
                    String columnName = column.getColumnName();
                    Object value = ExpressionUtils.convertExpression(expressions.get(columnIndex), params);
                    // TODO value = Utils.convertToColumnType(tableInfo, columnName, value);
                    value = DataTypeConverter.convertToDatastore(value, datastoreTable, columnName);
                    entity.setProperty(columnName, value);
                }
            }
            if (conn.transaction != null){
                conn.datastore.put(conn.transaction, entity);
            } else {
                conn.datastore.put(entity);
            }
        }
        
        return entities.size();
    }

    protected int executeDelete(Delete delete, Map<Integer, Object> params) throws SQLException {
        if (params == null){
            params = new HashMap<Integer, Object>();
        }
        
        Table table = delete.getTable();
        String tableName = table.getName();
        Query q = new Query(tableName);
        Query.Filter filter = ExpressionUtils.buildFilterFromWhereClause(delete.getWhere(), params);
        if (filter != null){
            q.setFilter(filter);
        }
        q.setKeysOnly();
        
        PreparedQuery pq = conn.datastore.prepare(q);
        
        List<com.google.appengine.api.datastore.Key> keys = new ArrayList<com.google.appengine.api.datastore.Key>();
        for (Entity entity : pq.asIterable()){
            keys.add(entity.getKey());
        }
        conn.datastore.delete(keys);
        
        return keys.size();
    }
    
    protected void warnIfQueryInsideTransaction(){
        if (conn.transaction != null){
            System.err.println("WARN: Queries and gets inside transaction do *not* see the results of previous writes inside that transaction");
            System.err.println("See more details at: https://cloud.google.com/appengine/docs/standard/java/datastore/transactions");
            System.err.println();
        }
    }
    
    private void notImplemented(){
        RuntimeException e = new UnsupportedOperationException("DatastoreStatement: Not implemented");
        e.printStackTrace();
        throw e;
    }
}
